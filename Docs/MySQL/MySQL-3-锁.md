# MySQL 锁

## 概述

锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

## 全局锁

锁定数据库中所有的表

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML写语句、DDL语句，以及更新操作的事务提交语句都将被阻塞。

其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

### 说明

比如当前正在进行备份数据库，但是备份时候可能会遇到别人在执行DDL语句，比如删除、更新、添加。如果这时候在备份过程中出现增删改情况，那么可能就无法保证数据的一致性。

所以为了保证数据的一致性，要为其加上全局锁。虽然加上了全局锁，但是可以对数据库进行查询操作，只是无法进行增删改。

执行时可以使用`mysqldump`指令进行数据库备份。

### 操作

```mysql
# 加上全局锁，此时只能查询不能增删改
flush tables with read lock;

# 释放锁
unlock tables;
```

在`InnoDB`引擎中，我们可以在备份时加上参数`--single-transaction`来完成不加锁的一致性数据备份：

```mysql
mysqldump --single-transaction -uroot -p1234 数据库名称 > 名称.sql
```

## 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在`MyISAM`、`InnoDB`、`BDB`等存储引擎中。

### 分类

对于表级锁，主要分为以下三类：

1. 表锁
2. 元数据锁（`metadata lock`，`MDL`）
   - MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。
   - 在MySQL 5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁（共享）；当对表结构进行变更操作的时候，加MDL写锁（排他）。
3. 意向锁

### 表锁

对于表锁，分为两类：

1. 表共享读锁（read lock）
2. 表独占写锁（write lock）

#### 语法

1. 加锁：`lock tables 表名... read/write`
2. 释放锁：`unlock tables` / 客户端断开连接

读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

### 意向锁

1. 意向共享锁（IS）：与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。
2. 意向排他锁（IX）：与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥。

## 行级锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。

`InnoDB`的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

1. 行锁（`Record Lock`）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。
2. 间隙锁（`Gap Lock`）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下支持。
3. 临键锁（`Next-key Lock`）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

### 行锁

`InnoDB`实现了以下两种类型的行锁：

1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
2. 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

| 请求锁类型/当前锁类型 | S(共享锁) | X(排他锁) |
| --------------------- | --------- | --------- |
| S(共享锁)             | 兼容      | 冲突      |
| X(排他锁)             | 冲突      | 冲突      |

常见SQL操作的锁类型：

| SQL                           | 行锁类型   | 说明                                     |
| ----------------------------- | ---------- | ---------------------------------------- |
| INSERT                        | 排他锁     | 自动加锁                                 |
| UPDATE                        | 排他锁     | 自动加锁                                 |
| DELETE                        | 排他锁     | 自动加锁                                 |
| SELECT(正常)                  | 不加任何锁 |                                          |
| SELECT ... LOCK IN SHARE MODE | 共享锁     | 需要手动在SELECT之后加LOCK IN SHARE MODE |
| SELECT ... FOR UPDATE         | 排他锁     | 需要手动在SELECT之后加FOR UPDATE         |

默认情况下，`InnoDB`在REPEATABLE READ事务隔离级别运行，`InnoDB`使用next-key锁进行搜索和索引扫描，以防止幻读。

1. 针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。
2. `InnoDB`的行锁是针对于索引加的锁，不通过索引条件检索数据，那么`InnoDB`将对表中的所有记录加锁，此时就会升级为表锁。

### 间隙锁

> [!WARNING]
> 间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。

默认情况下，`InnoDB`在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。

1. 索引上的等值查询（唯一索引），给不存在的记录加锁时，优化为间隙锁。
2. 索引上的等值查询（普通索引），向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。
3. 索引上的范围查询（唯一索引）--会访问到不满足条件的第一个值为止。